name: Multi-Platform Media Generator

on:
  schedule:
    - cron: '0 */2 * * *'  # Check every 2 hours
    - cron: '0 18 * * 0'   # Special check Sundays at 6pm Central (00:00 UTC Monday)
  workflow_dispatch:
    inputs:
      force_refresh:
        description: 'Force refresh all episodes'
        required: false
        default: false
        type: boolean
      skip_sermon_check:
        description: 'Skip missing sermon detection'
        required: false
        default: false
        type: boolean
  push:
    branches: [ main ]
    paths:
      - 'config.json'

permissions:
  contents: write

jobs:
  validate-and-check:
    runs-on: ubuntu-latest
    outputs:
      should-continue: ${{ steps.sermon-check.outputs.should-continue }}
      sermon-status: ${{ steps.sermon-check.outputs.status }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Validate configuration
      run: |
        echo "ðŸ” Validating configuration..."
        
        if [ ! -f "config.json" ]; then
          echo "âŒ config.json not found!"
          exit 1
        fi
        
        if ! jq . config.json > /dev/null 2>&1; then
          echo "âŒ config.json contains invalid JSON!"
          exit 1
        fi
        
        echo "âœ… Configuration valid"
        jq '.outputs' config.json
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Check for missing sermon
      id: sermon-check
      run: |
        echo "ðŸ• Checking for expected sermon..."
        
        cat > check-sermon.js << 'SCRIPT_EOF'
        const fs = require('fs');
        const https = require('https');
        
        let config;
        try {
          config = JSON.parse(fs.readFileSync('config.json', 'utf8'));
        } catch (error) {
          console.error('âŒ Error reading config:', error);
          process.exit(1);
        }
        
        function getCentralTime() {
          const now = new Date();
          const centralTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          return centralTime;
        }
        
        function getLastSunday() {
          const now = getCentralTime();
          const dayOfWeek = now.getDay(); // 0 = Sunday
          const daysBack = dayOfWeek === 0 ? 0 : dayOfWeek;
          const lastSunday = new Date(now);
          lastSunday.setDate(now.getDate() - daysBack);
          lastSunday.setHours(11, 0, 0, 0); // 11 AM service time
          return lastSunday;
        }
        
        function shouldCheckForSermon() {
          if (process.env.SKIP_SERMON_CHECK === 'true') {
            console.log('ðŸ“‹ Sermon check skipped by user input');
            return false;
          }
          
          const now = getCentralTime();
          const lastSunday = getLastSunday();
          const dayOfWeek = now.getDay();
          const hour = now.getHours();
          
          // Check on Sunday after 5 PM, or any time Monday-Saturday
          const shouldCheck = (dayOfWeek === 0 && hour >= 17) || dayOfWeek > 0;
          
          console.log('ðŸ“… Current time: ' + now.toLocaleString());
          console.log('ðŸ“… Last Sunday service: ' + lastSunday.toLocaleString());
          console.log('ðŸ” Should check for sermon: ' + shouldCheck);
          
          return shouldCheck;
        }
        
        async function fetchVimeoData() {
          return new Promise((resolve, reject) => {
            const url = config.vimeoFeedUrl || config.platformConfigs?.vimeo?.feedUrl;
            if (!url) {
              reject(new Error('No Vimeo feed URL configured'));
              return;
            }
            
            console.log('ðŸ“¡ Fetching from:', url);
            
            https.get(url, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                try {
                  const vimeoData = JSON.parse(data);
                  resolve(vimeoData);
                } catch (error) {
                  reject(error);
                }
              });
            }).on('error', reject);
          });
        }
        
        async function sendPushoverNotification(message, priority = 0) {
          if (!config.pushover?.enabled) {
            console.log('ðŸ“± Pushover disabled, skipping notification');
            return;
          }
          
          const userKey = process.env.PUSHOVER_USER_KEY;
          const appToken = process.env.PUSHOVER_APP_TOKEN;
          
          if (!userKey || !appToken) {
            console.error('âŒ Pushover credentials not configured');
            return;
          }
          
          const postData = JSON.stringify({
            token: appToken,
            user: userKey,
            message: message,
            title: 'Sermon Feed Alert',
            priority: priority,
            sound: priority > 0 ? 'falling' : 'pushover'
          });
          
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.pushover.net',
              port: 443,
              path: '/1/messages.json',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
              }
            };
            
            const req = https.request(options, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                if (res.statusCode === 200) {
                  console.log('ðŸ“± Pushover notification sent successfully');
                  resolve(data);
                } else {
                  console.error('âŒ Pushover notification failed:', res.statusCode, data);
                  reject(new Error('Pushover failed: ' + res.statusCode));
                }
              });
            });
            
            req.on('error', reject);
            req.write(postData);
            req.end();
          });
        }
        
        async function checkSermonExpectation(vimeoData) {
          const lastSunday = getLastSunday();
          const graceHours = config.schedule?.graceHours || 6;
          const gracePeriod = new Date(lastSunday.getTime() + (graceHours * 60 * 60 * 1000));
          
          if (!vimeoData.movies || vimeoData.movies.length === 0) {
            return {
              isMissing: true,
              message: 'No videos found in Vimeo feed',
              shouldStop: true
            };
          }
          
          // Get the most recent video
          const latestVideo = vimeoData.movies
            .sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate))[0];
          
          const latestDate = new Date(latestVideo.releaseDate);
          const timeSinceService = getCentralTime() - lastSunday;
          const timeSinceLatest = getCentralTime() - latestDate;
          
          console.log('ðŸ“¹ Latest video: "' + latestVideo.title + '"');
          console.log('ðŸ“… Latest video date (raw): ' + latestVideo.releaseDate);
          console.log('ðŸ“… Latest video date (parsed): ' + latestDate.toLocaleString());
          console.log('â° Time since service: ' + Math.round(timeSinceService / (1000 * 60 * 60)) + ' hours');
          console.log('â° Time since latest video: ' + Math.round(timeSinceLatest / (1000 * 60 * 60)) + ' hours');
          
          // Account for Vimeo's 7-day date offset issue
          const adjustedLatestDate = new Date(latestDate.getTime() + (7 * 24 * 60 * 60 * 1000)); // Add 7 days
          const adjustedTimeSinceLatest = getCentralTime() - adjustedLatestDate;
          
          console.log('ðŸ“… Adjusted latest video date (+7 days): ' + adjustedLatestDate.toLocaleString());
          console.log('â° Adjusted time since latest video: ' + Math.round(adjustedTimeSinceLatest / (1000 * 60 * 60)) + ' hours');
          
          // Check if adjusted date is from expected service
          const videoFromExpectedService = adjustedLatestDate >= lastSunday && adjustedLatestDate <= gracePeriod;
          
          // Also check if the video was uploaded recently (within last 24 hours) regardless of date
          const wasUploadedRecently = Math.abs(adjustedTimeSinceLatest) < (24 * 60 * 60 * 1000);
          
          console.log('ðŸŽ¯ Video from expected service window: ' + videoFromExpectedService);
          console.log('ðŸ• Video uploaded recently: ' + wasUploadedRecently);
          
          if (!videoFromExpectedService && !wasUploadedRecently && timeSinceService > (graceHours * 60 * 60 * 1000)) {
            const message = 'Missing expected sermon from ' + lastSunday.toLocaleDateString() + '. Latest video: "' + latestVideo.title + '" from ' + latestVideo.releaseDate + ' (Vimeo date may be offset).';
            
            await sendPushoverNotification(message, 1); // High priority
            
            return {
              isMissing: true,
              message: message,
              shouldStop: true
            };
          }
          
          return {
            isMissing: false,
            message: 'Latest sermon found: "' + latestVideo.title + '" (accounting for Vimeo date offset)',
            shouldStop: false
          };
        }
        
        async function main() {
          try {
            if (!shouldCheckForSermon()) {
              console.log('âœ… Sermon check not needed at this time');
              console.log('should-continue=true');
              console.log('status=skipped');
              return;
            }
            
            const vimeoData = await fetchVimeoData();
            const result = await checkSermonExpectation(vimeoData);
            
            console.log('ðŸ“Š Sermon check result: ' + result.message);
            
            if (result.shouldStop) {
              console.log('should-continue=false');
              console.log('status=missing');
            } else {
              console.log('should-continue=true');
              console.log('status=found');
            }
            
          } catch (error) {
            console.error('âŒ Error during sermon check:', error);
            
            // Send error notification
            if (config.pushover?.enabled) {
              await sendPushoverNotification('Sermon check failed: ' + error.message, 0);
            }
            
            console.log('should-continue=true'); // Continue on error
            console.log('status=error');
          }
        }
        
        main();
        SCRIPT_EOF
        
        # Run the sermon check and capture outputs
        node check-sermon.js > check_output.txt 2>&1
        
        # Extract outputs from the script
        if grep -q "should-continue=false" check_output.txt; then
          echo "should-continue=false" >> $GITHUB_OUTPUT
        else
          echo "should-continue=true" >> $GITHUB_OUTPUT
        fi
        
        if grep -q "status=missing" check_output.txt; then
          echo "status=missing" >> $GITHUB_OUTPUT
        elif grep -q "status=found" check_output.txt; then
          echo "status=found" >> $GITHUB_OUTPUT
        elif grep -q "status=skipped" check_output.txt; then
          echo "status=skipped" >> $GITHUB_OUTPUT
        else
          echo "status=error" >> $GITHUB_OUTPUT
        fi
        
        # Show the output
        cat check_output.txt
        
      env:
        PUSHOVER_USER_KEY: ${{ secrets.PUSHOVER_USER_KEY }}
        PUSHOVER_APP_TOKEN: ${{ secrets.PUSHOVER_APP_TOKEN }}
        SKIP_SERMON_CHECK: ${{ github.event.inputs.skip_sermon_check }}

  generate-feeds:
    needs: validate-and-check
    runs-on: ubuntu-latest
    if: needs.validate-and-check.outputs.should-continue == 'true'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Setup FFmpeg
      run: |
        echo "ðŸ“¦ Installing FFmpeg via apt..."
        sudo apt-get update
        sudo apt-get install -y ffmpeg
        ffmpeg -version
      
    - name: Generate all feeds and media
      run: |
        echo "ðŸš€ Starting comprehensive feed generation..."
        
        cat > generate-comprehensive.js << 'SCRIPT_EOF'
        const fs = require('fs');
        const https = require('https');
        const { spawn } = require('child_process');
        const { URL } = require('url');
        
        console.log('ðŸš€ Starting comprehensive feed generation...');
        
        let config;
        try {
          config = JSON.parse(fs.readFileSync('config.json', 'utf8'));
          console.log('âœ… Config loaded:', config.podcastTitle);
        } catch (error) {
          console.error('âŒ Error reading config:', error);
          process.exit(1);
        }
        
        // Enhanced XML escaping
        function escapeXML(str) {
          if (!str) return '';
          return str.toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/&rsquo;/g, "'")
            .replace(/&lsquo;/g, "'")
            .replace(/&ldquo;/g, '"')
            .replace(/&rdquo;/g, '"')
            .replace(/&ndash;/g, '-')
            .replace(/&mdash;/g, '--')
            .replace(/&hellip;/g, '...')
            .replace(/&nbsp;/g, ' ')
            .replace(/<[^>]*>/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        }
        
        function formatRFC2822Date(dateString) {
          const date = new Date(dateString);
          return isNaN(date.getTime()) ? new Date().toUTCString() : date.toUTCString();
        }
        
        function formatDuration(seconds) {
          if (!seconds || seconds <= 0) return '0:00';
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          return hours > 0 ? 
            hours + ':' + minutes.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0') :
            minutes + ':' + secs.toString().padStart(2, '0');
        }
        
        // Enhanced Vimeo Roku feed fetcher
        async function fetchVimeoData() {
          return new Promise((resolve, reject) => {
            const url = config.vimeoFeedUrl;
            if (!url) {
              reject(new Error('No Vimeo feed URL configured'));
              return;
            }
            
            console.log('ðŸ“¡ Fetching from Vimeo Roku feed:', url);
            
            https.get(url, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                try {
                  const vimeoData = JSON.parse(data);
                  
                  // The Vimeo Roku feed already has the right structure!
                  // Just enhance it with our additional processing
                  const episodes = vimeoData.movies?.map(movie => {
                    const videoFormats = {};
                    
                    // Extract all video formats from Roku feed
                    if (movie.content?.videos) {
                      movie.content.videos.forEach(video => {
                        if (video.videoType === 'HLS' || video.url.includes('.m3u8')) {
                          videoFormats.hls = video.url;
                        } else if (video.videoType === 'MP4') {
                          const quality = video.quality?.toLowerCase() || 'hd';
                          videoFormats['mp4_' + quality] = video.url;
                        }
                      });
                    }
                    
                    return {
                      id: movie.id,
                      title: movie.title,
                      description: movie.shortDescription || movie.title,
                      thumbnail: movie.thumbnail,
                      releaseDate: movie.releaseDate,
                      duration: movie.content?.duration || 0,
                      videoFormats: videoFormats,
                      primaryVideoUrl: movie.content?.videos?.[0]?.url,
                      quality: movie.content?.videos?.[0]?.quality || 'HD',
                      tags: movie.tags || [],
                      genres: movie.genres || [],
                      // Keep original Roku data for passthrough
                      originalRokuData: movie
                    };
                  }) || [];
                  
                  console.log('âœ… Processed ' + episodes.length + ' episodes from Vimeo Roku feed');
                  resolve({
                    ...vimeoData,
                    episodes: episodes
                  });
                } catch (error) {
                  reject(error);
                }
              });
            }).on('error', reject);
          });
        }
        
        // File size detection
        async function getFileSize(url) {
          return new Promise((resolve) => {
            try {
              const urlObj = new URL(url);
              const requester = urlObj.protocol === 'https:' ? https : require('http');
              
              const request = requester.request(url, { method: 'HEAD' }, (res) => {
                resolve(res.headers['content-length'] || '0');
              });
              
              request.on('error', () => resolve('0'));
              request.setTimeout(8000, () => {
                request.destroy();
                resolve('0');
              });
              
              request.end();
            } catch (error) {
              resolve('0');
            }
          });
        }
        
        // Video Podcast RSS Generator
        async function generateVideoRSS(vimeoData) {
          if (!config.outputs?.videoPodcast?.enabled) return null;
          
          console.log('ðŸ“º Generating video podcast RSS...');
          
          const baseUrl = config.baseUrl || 'https://heritagecoc.github.io/heritage-media-feeds';
          const artworkUrl = config.podcastArtwork?.startsWith('http') ? 
            config.podcastArtwork : baseUrl + '/' + config.podcastArtwork.replace('./', '');
          
          const now = formatRFC2822Date(new Date().toISOString());
          
          let rss = '<?xml version="1.0" encoding="UTF-8"?>\n';
          rss += '<rss version="2.0" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd">\n';
          rss += '<channel>\n';
          rss += '    <title>' + escapeXML(config.podcastTitle) + ' - Video</title>\n';
          rss += '    <link>' + escapeXML(config.churchWebsite || baseUrl) + '</link>\n';
          rss += '    <description>' + escapeXML(config.podcastDescription) + ' - Full video sermons</description>\n';
          rss += '    <language>' + escapeXML(config.podcastLanguage || 'en') + '</language>\n';
          rss += '    <pubDate>' + now + '</pubDate>\n';
          rss += '    <lastBuildDate>' + now + '</lastBuildDate>\n';
          rss += '    <itunes:author>' + escapeXML(config.podcastAuthor) + '</itunes:author>\n';
          rss += '    <itunes:image href="' + escapeXML(artworkUrl) + '" />\n';
          rss += '    <itunes:explicit>false</itunes:explicit>\n';
          
          // Use existing category structure
          if (config.podcastSubcategory) {
            rss += '    <itunes:category text="' + escapeXML(config.podcastCategory) + '">\n';
            rss += '        <itunes:category text="' + escapeXML(config.podcastSubcategory) + '" />\n';
            rss += '    </itunes:category>\n';
          } else {
            rss += '    <itunes:category text="' + escapeXML(config.podcastCategory || 'Religion & Spirituality') + '" />\n';
          }
          
          const sortedEpisodes = vimeoData.episodes.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
          
          for (let i = 0; i < sortedEpisodes.length; i++) {
            const episode = sortedEpisodes[i];
            if (!episode.primaryVideoUrl) continue;
            
            const episodeNumber = sortedEpisodes.length - i;
            const pubDate = formatRFC2822Date(episode.releaseDate);
            const duration = formatDuration(episode.duration);
            const fileSize = await getFileSize(episode.primaryVideoUrl);
            
            rss += '\n    <item>\n';
            rss += '        <title>' + escapeXML(episode.title) + '</title>\n';
            rss += '        <description>' + escapeXML(episode.description) + '</description>\n';
            rss += '        <guid isPermaLink="false">vimeo-video-' + escapeXML(episode.id) + '</guid>\n';
            rss += '        <pubDate>' + pubDate + '</pubDate>\n';
            rss += '        <enclosure url="' + escapeXML(episode.primaryVideoUrl) + '" length="' + fileSize + '" type="application/x-mpegURL" />\n';
            rss += '        <itunes:title>' + escapeXML(episode.title) + '</itunes:title>\n';
            rss += '        <itunes:duration>' + duration + '</itunes:duration>\n';
            rss += '        <itunes:episode>' + episodeNumber + '</itunes:episode>\n';
            
            if (episode.thumbnail) {
              rss += '        <itunes:image href="' + escapeXML(episode.thumbnail) + '" />\n';
            }
            
            rss += '    </item>';
          }
          
          rss += '\n\n</channel>\n</rss>';
          return rss;
        }
        
        // Enhanced Roku feed generator (optimized for existing Roku feed)
        async function generateRokuFeed(vimeoData) {
          if (!config.outputs?.roku?.enabled) return null;
          
          console.log('ðŸ“º Generating enhanced Roku Direct Publisher feed...');
          
          // Since your Vimeo feed is already Roku-compatible, we can enhance it
          const enhancedRokuFeed = {
            providerName: config.podcastAuthor,
            language: config.podcastLanguage || 'en',
            lastUpdated: new Date().toISOString(),
            movies: []
          };
          
          const sortedEpisodes = vimeoData.episodes.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
          
          for (const episode of sortedEpisodes) {
            if (!episode.primaryVideoUrl) continue;
            
            // Use original Roku data as base, then enhance
            const rokuEpisode = {
              ...episode.originalRokuData,
              // Ensure these fields are properly set
              id: episode.id,
              title: episode.title,
              shortDescription: episode.description,
              thumbnail: episode.thumbnail || '',
              releaseDate: episode.releaseDate,
              genres: episode.genres.length > 0 ? episode.genres : ['faith'],
              tags: episode.tags.length > 0 ? episode.tags : ['sermon']
            };
            
            // Ensure content structure is complete
            if (!rokuEpisode.content) {
              rokuEpisode.content = {
                dateAdded: episode.releaseDate,
                captions: [],
                duration: episode.duration,
                videos: []
              };
            }
            
            // Ensure videos array is populated
            if (!rokuEpisode.content.videos || rokuEpisode.content.videos.length === 0) {
              rokuEpisode.content.videos = [];
              
              if (episode.videoFormats.hls) {
                rokuEpisode.content.videos.push({
                  url: episode.videoFormats.hls,
                  quality: 'HD',
                  videoType: 'HLS'
                });
              }
              
              // Add MP4 versions if available
              Object.entries(episode.videoFormats).forEach(([format, url]) => {
                if (format.startsWith('mp4_')) {
                  const quality = format.replace('mp4_', '').toUpperCase();
                  rokuEpisode.content.videos.push({
                    url: url,
                    quality: quality,
                    videoType: 'MP4'
                  });
                }
              });
            }
            
            enhancedRokuFeed.movies.push(rokuEpisode);
          }
          
          return JSON.stringify(enhancedRokuFeed, null, 2);
        }
        
        // Enhanced Phone Quality MP3 Generator with Smart Trimming
        async function generatePhoneQualityMp3(vimeoData) {
          if (!config.outputs?.phoneTree?.enabled) return null;
          
          console.log('ðŸ“ž Generating phone quality MP3 with smart trimming...');
          
          const latestEpisode = vimeoData.episodes
            .sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate))[0];
          
          if (!latestEpisode || !latestEpisode.primaryVideoUrl) {
            console.warn('âš ï¸ No latest episode found for phone MP3');
            return null;
          }
          
          const smartTrimming = config.outputs.phoneTree.smartTrimming;
          const generateBoth = smartTrimming?.enabled && smartTrimming?.generateBothVersions;
          
          return new Promise((resolve, reject) => {
            console.log('ðŸŽµ Converting "' + latestEpisode.title + '" to phone quality MP3...');
            
            // Generate trimmed version first if smart trimming is enabled
            const generateTrimmed = () => {
              return new Promise((resolveTrimmed, rejectTrimmed) => {
                if (!smartTrimming?.enabled) {
                  console.log('ðŸ“± Smart trimming disabled - generating full audio');
                  generateStandardMp3(resolveTrimmed, rejectTrimmed);
                  return;
                }
                
                console.log('âœ‚ï¸ Analyzing audio for smart trimming...');
                
                // Step 1: Analyze audio to find trim points
                const analyzeArgs = [
                  '-i', latestEpisode.primaryVideoUrl,
                  '-af', 'silencedetect=noise=' + smartTrimming.silenceThreshold + 'dB:duration=5',
                  '-f', 'null',
                  '-'
                ];
                
                const analyze = spawn('ffmpeg', analyzeArgs);
                let analysisOutput = '';
                
                analyze.stderr.on('data', (data) => {
                  analysisOutput += data.toString();
                });
                
                analyze.on('close', (code) => {
                  try {
                    const trimPoints = detectTrimPoints(analysisOutput, latestEpisode.duration);
                    console.log('ðŸŽ¯ Detected trim points: ' + trimPoints.start + 's to ' + trimPoints.end + 's');
                    
                    // Step 2: Generate trimmed MP3
                    const trimmedArgs = [
                      '-i', latestEpisode.primaryVideoUrl,
                      '-ss', trimPoints.start.toString(),
                      '-to', trimPoints.end.toString(),
                      '-vn', // No video
                      '-acodec', 'mp3',
                      '-ar', '22050',
                      '-ab', '64k',
                      '-ac', '1',
                      '-f', 'mp3',
                      '-y',
                      'latest-sermon-phone.mp3'
                    ];
                    
                    const ffmpegTrimmed = spawn('ffmpeg', trimmedArgs);
                    let stderrTrimmed = '';
                    
                    ffmpegTrimmed.stderr.on('data', (data) => {
                      stderrTrimmed += data.toString();
                    });
                    
                    ffmpegTrimmed.on('close', (trimCode) => {
                      if (trimCode === 0) {
                        const trimmedInfo = {
                          title: latestEpisode.title,
                          date: latestEpisode.releaseDate,
                          originalDuration: latestEpisode.duration,
                          trimmedDuration: trimPoints.end - trimPoints.start,
                          trimStartTime: formatTime(trimPoints.start),
                          trimEndTime: formatTime(trimPoints.end),
                          trimmingApplied: true,
                          trimmedUrl: (config.baseUrl || 'https://heritagecoc.github.io/podcast') + '/latest-sermon-phone.mp3',
                          generated: new Date().toISOString()
                        };
                        
                        console.log('âœ… Trimmed MP3 generated: ' + trimmedInfo.trimmedDuration + 's (removed ' + (latestEpisode.duration - trimmedInfo.trimmedDuration) + 's)');
                        resolveTrimmed(trimmedInfo);
                      } else {
                        console.warn('âš ï¸ Smart trimming failed, falling back to full audio');
                        generateStandardMp3(resolveTrimmed, rejectTrimmed);
                      }
                    });
                    
                  } catch (error) {
                    console.warn('âš ï¸ Audio analysis failed, falling back to full audio:', error);
                    generateStandardMp3(resolveTrimmed, rejectTrimmed);
                  }
                });
                
                analyze.on('error', () => {
                  console.warn('âš ï¸ Audio analysis failed, falling back to full audio');
                  generateStandardMp3(resolveTrimmed, rejectTrimmed);
                });
              });
            };
            
            // Generate standard full MP3
            const generateStandardMp3 = (resolveStd, rejectStd) => {
              const standardArgs = [
                '-i', latestEpisode.primaryVideoUrl,
                '-vn',
                '-acodec', 'mp3',
                '-ar', '22050',
                '-ab', '64k',
                '-ac', '1',
                '-f', 'mp3',
                '-y',
                generateBoth ? 'latest-sermon-phone-full.mp3' : 'latest-sermon-phone.mp3'
              ];
              
              const ffmpegStandard = spawn('ffmpeg', standardArgs);
              let stderrStandard = '';
              
              ffmpegStandard.stderr.on('data', (data) => {
                stderrStandard += data.toString();
              });
              
              ffmpegStandard.on('close', (stdCode) => {
                if (stdCode === 0) {
                  const standardInfo = {
                    title: latestEpisode.title,
                    date: latestEpisode.releaseDate,
                    originalDuration: latestEpisode.duration,
                    trimmedDuration: latestEpisode.duration,
                    trimmingApplied: false,
                    url: (config.baseUrl || 'https://heritagecoc.github.io/podcast') + '/latest-sermon-phone.mp3',
                    generated: new Date().toISOString()
                  };
                  
                  console.log('âœ… Standard MP3 generated successfully');
                  resolveStd(standardInfo);
                } else {
                  console.error('âŒ Standard MP3 generation failed:', stderrStandard);
                  rejectStd(new Error('FFmpeg failed with code ' + stdCode));
                }
              });
              
              ffmpegStandard.on('error', rejectStd);
            };
            
            // Main generation flow
            if (generateBoth) {
              console.log('ðŸ”„ Generating both trimmed and full versions...');
              
              Promise.all([
                generateTrimmed(),
                new Promise((resolveFull, rejectFull) => generateStandardMp3(resolveFull, rejectFull))
              ]).then(([trimmedInfo, fullInfo]) => {
                // Simple notification without interactive approval
                sendSimplePhoneNotification(trimmedInfo, fullInfo).then(() => {
                  // Log the decision point
                  logPhoneDecision('generated_both', trimmedInfo, fullInfo);
                  resolve(trimmedInfo); // Return trimmed as default
                }).catch(error => {
                  console.error('âš ï¸ Pushover notification failed:', error);
                  resolve(trimmedInfo); // Continue anyway
                });
              }).catch(reject);
              
            } else {
              // Generate only one version
              generateTrimmed().then(resolve).catch(reject);
            }
          });
        }
        
        // Helper function to detect trim points from silence analysis
        function detectTrimPoints(analysisOutput, totalDuration) {
          const smartTrimming = config.outputs.phoneTree.smartTrimming;
          const startBuffer = smartTrimming?.startBuffer || 30;
          const endBuffer = smartTrimming?.endBuffer || 60;
          const minLength = (smartTrimming?.minServiceLength || 45) * 60; // Convert to seconds
          const maxLength = (smartTrimming?.maxServiceLength || 90) * 60;
          
          // Parse silence detection output
          const silenceRegex = /silence_start: ([\d.]+)/g;
          const silenceEndRegex = /silence_end: ([\d.]+)/g;
          
          let silenceStarts = [];
          let silenceEnds = [];
          let match;
          
          while ((match = silenceRegex.exec(analysisOutput)) !== null) {
            silenceStarts.push(parseFloat(match[1]));
          }
          
          while ((match = silenceEndRegex.exec(analysisOutput)) !== null) {
            silenceEnds.push(parseFloat(match[1]));
          }
          
          // Conservative trimming logic
          let trimStart = 0;
          let trimEnd = totalDuration;
          
          // Find start point: first significant silence end (service likely starts after)
          if (silenceEnds.length > 0) {
            const firstSignificantSilenceEnd = silenceEnds.find(end => end > 60); // Skip very early silence
            if (firstSignificantSilenceEnd) {
              trimStart = Math.max(0, firstSignificantSilenceEnd - startBuffer);
            }
          }
          
          // Find end point: last significant silence start (service likely ends before)
          if (silenceStarts.length > 0) {
            const lastSignificantSilenceStart = silenceStarts.reverse().find(start => 
              start < totalDuration - 60 && // Not too close to end
              (totalDuration - start) > 120  // At least 2 minutes of silence
            );
            if (lastSignificantSilenceStart) {
              trimEnd = lastSignificantSilenceStart + endBuffer;
            }
          }
          
          // Sanity checks
          const trimmedLength = trimEnd - trimStart;
          if (trimmedLength < minLength || trimmedLength > maxLength) {
            console.log('âš ï¸ Trimmed length ' + Math.round(trimmedLength/60) + 'min outside expected range, using full audio');
            return { start: 0, end: totalDuration };
          }
          
          return { start: Math.round(trimStart), end: Math.round(trimEnd) };
        }
        
        // Helper function to format seconds as HH:MM:SS
        function formatTime(seconds) {
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          return hours > 0 ? 
            hours + ':' + minutes.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0') :
            minutes + ':' + secs.toString().padStart(2, '0');
        }
        
        // Send simple Pushover notification (no interactive approval)
        async function sendSimplePhoneNotification(trimmedInfo, fullInfo) {
          if (!config.pushover?.enabled) {
            console.log('ðŸ“± Pushover notifications disabled');
            return;
          }
          
          const userKey = process.env.PUSHOVER_USER_KEY;
          const appToken = process.env.PUSHOVER_APP_TOKEN;
          
          if (!userKey || !appToken) {
            console.error('âŒ Pushover credentials not configured');
            return;
          }
          
          const trimmedSize = fs.existsSync('latest-sermon-phone.mp3') ? 
            (fs.statSync('latest-sermon-phone.mp3').size / 1024 / 1024).toFixed(1) + ' MB' : 'Unknown';
          const fullSize = fs.existsSync('latest-sermon-phone-full.mp3') ? 
            (fs.statSync('latest-sermon-phone-full.mp3').size / 1024 / 1024).toFixed(1) + ' MB' : 'Unknown';
          
          const trimmedDurationMin = Math.round(trimmedInfo.trimmedDuration / 60);
          const fullDurationMin = Math.round(fullInfo.originalDuration / 60);
          const removedMin = fullDurationMin - trimmedDurationMin;
          
          const message = 'ðŸ“ž Phone Audio Generated for "' + trimmedInfo.title + '":\n\n' +
            'ðŸŽ¯ Trimmed Version: ' + trimmedSize + ' (' + trimmedDurationMin + ' min) - Active\n' +
            'ðŸ“¹ Full Version: ' + fullSize + ' (' + fullDurationMin + ' min) - Backup\n' +
            'âœ‚ï¸ Removed: ' + removedMin + ' minutes of silence/intro/outro\n\n' +
            'Both versions available for download.';
          
          const postData = JSON.stringify({
            token: appToken,
            user: userKey,
            message: message,
            title: 'Sermon Audio Ready',
            url: trimmedInfo.trimmedUrl,
            url_title: "Download Trimmed Audio",
            priority: 0,
            sound: "pushover"
          });
          
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.pushover.net',
              port: 443,
              path: '/1/messages.json',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
              }
            };
            
            const req = https.request(options, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                if (res.statusCode === 200) {
                  console.log('ðŸ“± Simple Pushover notification sent successfully');
                  resolve(data);
                } else {
                  console.error('âŒ Pushover notification failed:', res.statusCode, data);
                  reject(new Error('Pushover failed: ' + res.statusCode));
                }
              });
            });
            
            req.on('error', reject);
            req.write(postData);
            req.end();
          });
        }
        
        // Log phone audio decisions
        function logPhoneDecision(action, trimmedInfo, fullInfo = null) {
          try {
            const logEntry = {
              timestamp: new Date().toISOString(),
              action: action, // 'generated_both', 'trimmed_only', 'full_only'
              sermon: {
                title: trimmedInfo.title,
                date: trimmedInfo.date
              },
              trimmed: {
                duration: trimmedInfo.trimmedDuration,
                size: fs.existsSync('latest-sermon-phone.mp3') ? fs.statSync('latest-sermon-phone.mp3').size : 0
              },
              full: fullInfo ? {
                duration: fullInfo.originalDuration,
                size: fs.existsSync('latest-sermon-phone-full.mp3') ? fs.statSync('latest-sermon-phone-full.mp3').size : 0
              } : null,
              trimmingApplied: trimmedInfo.trimmingApplied
            };
            
            // Append to log file
            const logLine = JSON.stringify(logEntry) + '\n';
            fs.appendFileSync('phone-audio-decisions.log', logLine);
            
            console.log('ðŸ“ Logged phone audio decision: ' + action);
          } catch (error) {
            console.error('âš ï¸ Failed to log phone decision:', error);
          }
        }
        
        // Main execution
        async function main() {
          try {
            console.log('ðŸ“¡ Fetching Vimeo data...');
            const vimeoData = await fetchVimeoData();
            
            if (!vimeoData.episodes || vimeoData.episodes.length === 0) {
              console.warn('âš ï¸ No episodes found');
              return;
            }
            
            console.log('ðŸ“ Found ' + vimeoData.episodes.length + ' episodes...');
            
            // Check if content has changed since last run
            const hasContentChanged = await checkForContentChanges(vimeoData);
            
            if (!hasContentChanged && !process.env.FORCE_REFRESH) {
              console.log('â„¹ï¸ No new content detected - skipping file generation');
              console.log('ðŸ“Š Feeds are up to date');
              return;
            }
            
            console.log('ðŸ”„ Content changes detected - generating feeds...');
            
            const results = {};
            
            // Generate video podcast RSS
            if (config.outputs?.videoPodcast?.enabled) {
              const videoRSS = await generateVideoRSS(vimeoData);
              if (videoRSS) {
                fs.writeFileSync('feed-video.xml', videoRSS, 'utf8');
                results.videoPodcast = 'feed-video.xml (' + fs.statSync('feed-video.xml').size + ' bytes)';
                console.log('âœ… Video podcast RSS generated');
              }
            }
            
            // Generate Roku feed
            if (config.outputs?.roku?.enabled) {
              const rokuFeed = await generateRokuFeed(vimeoData);
              if (rokuFeed) {
                fs.writeFileSync('roku-feed.json', rokuFeed, 'utf8');
                results.roku = 'roku-feed.json (' + fs.statSync('roku-feed.json').size + ' bytes)';
                console.log('âœ… Roku feed generated');
              }
            }
            
            // Generate phone quality MP3 (only if latest episode changed)
            if (config.outputs?.phoneTree?.enabled) {
              const shouldGeneratePhoneMp3 = await checkIfLatestEpisodeChanged(vimeoData);
              
              if (shouldGeneratePhoneMp3 || process.env.FORCE_REFRESH) {
                try {
                  const phoneInfo = await generatePhoneQualityMp3(vimeoData);
                  if (phoneInfo) {
                    results.phoneTree = 'latest-sermon-phone.mp3 (' + fs.statSync('latest-sermon-phone.mp3').size + ' bytes)';
                    console.log('âœ… Phone quality MP3 generated');
                  }
                } catch (error) {
                  console.error('âŒ Phone MP3 generation failed:', error);
                  results.phoneTree = 'Failed: ' + error.message;
                }
              } else {
                console.log('â„¹ï¸ Latest episode unchanged - skipping phone MP3 generation');
                results.phoneTree = 'Skipped (no changes)';
              }
            }
            
            // Update content hash for next run
            await updateContentHash(vimeoData);
            
            // Create summary
            console.log('\nðŸ“Š Generation Summary:');
            Object.entries(results).forEach(([type, result]) => {
              console.log('   ' + type + ': ' + result);
            });
            
            console.log('\nâœ… Comprehensive feed generation complete!');
            
          } catch (error) {
            console.error('âŒ Error during generation:', error);
            process.exit(1);
          }
        }
        
        // Check if content has changed since last run
        async function checkForContentChanges(vimeoData) {
          try {
            // Create a hash of current content
            const currentContent = {
              episodeCount: vimeoData.episodes.length,
              latestEpisode: vimeoData.episodes.length > 0 ? {
                id: vimeoData.episodes[0].id,
                title: vimeoData.episodes[0].title,
                releaseDate: vimeoData.episodes[0].releaseDate
              } : null,
              // Hash of all episode IDs and dates
              episodeSignature: vimeoData.episodes
                .map(ep => ep.id + ':' + ep.releaseDate)
                .sort()
                .join('|')
            };
            
            const currentHash = require('crypto')
              .createHash('sha256')
              .update(JSON.stringify(currentContent))
              .digest('hex');
            
            // Check if we have a previous hash
            let previousHash = '';
            try {
              if (fs.existsSync('.content-hash')) {
                previousHash = fs.readFileSync('.content-hash', 'utf8').trim();
              }
            } catch (error) {
              console.log('ðŸ“ No previous content hash found - treating as new content');
            }
            
            console.log('ðŸ” Content hash: ' + currentHash.substring(0, 12) + '...');
            console.log('ðŸ” Previous hash: ' + previousHash.substring(0, 12) + '...');
            
            return currentHash !== previousHash;
            
          } catch (error) {
            console.error('âš ï¸ Error checking content changes:', error);
            return true; // Generate on error to be safe
          }
        }
        
        // Check if latest episode specifically changed (for phone MP3)
        async function checkIfLatestEpisodeChanged(vimeoData) {
          if (vimeoData.episodes.length === 0) return false;
          
          try {
            const latestEpisode = vimeoData.episodes
              .sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate))[0];
            
            const currentLatest = latestEpisode.id + ':' + latestEpisode.releaseDate;
            
            let previousLatest = '';
            try {
              if (fs.existsSync('.latest-episode')) {
                previousLatest = fs.readFileSync('.latest-episode', 'utf8').trim();
              }
            } catch (error) {
              console.log('ðŸ“ No previous latest episode found');
            }
            
            console.log('ðŸŽ™ï¸ Current latest: ' + latestEpisode.title + ' (' + latestEpisode.id + ')');
            console.log('ðŸŽ™ï¸ Previous latest: ' + previousLatest);
            
            return currentLatest !== previousLatest;
            
          } catch (error) {
            console.error('âš ï¸ Error checking latest episode:', error);
            return true; // Generate on error
          }
        }
        
        // Update content hash for next run
        async function updateContentHash(vimeoData) {
          try {
            // Update overall content hash
            const currentContent = {
              episodeCount: vimeoData.episodes.length,
              latestEpisode: vimeoData.episodes.length > 0 ? {
                id: vimeoData.episodes[0].id,
                title: vimeoData.episodes[0].title,
                releaseDate: vimeoData.episodes[0].releaseDate
              } : null,
              episodeSignature: vimeoData.episodes
                .map(ep => ep.id + ':' + ep.releaseDate)
                .sort()
                .join('|')
            };
            
            const currentHash = require('crypto')
              .createHash('sha256')
              .update(JSON.stringify(currentContent))
              .digest('hex');
            
            fs.writeFileSync('.content-hash', currentHash);
            
            // Update latest episode tracking
            if (vimeoData.episodes.length > 0) {
              const latestEpisode = vimeoData.episodes
                .sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate))[0];
              const latestInfo = latestEpisode.id + ':' + latestEpisode.releaseDate;
              fs.writeFileSync('.latest-episode', latestInfo);
            }
            
            console.log('ðŸ’¾ Content tracking updated');
            
          } catch (error) {
            console.error('âš ï¸ Error updating content hash:', error);
          }
        }
        
        main();
        SCRIPT_EOF
        
        echo "ðŸ“ Running comprehensive feed generator..."
        node generate-comprehensive.js
    
    - name: Enhance Roku feed for Direct Publisher
      run: |
        echo "ðŸ“º Enhancing Roku feed for Direct Publisher..."
        if [ -f "roku-feed-enhancer.js" ]; then
          # Make script executable (handles GitHub web interface uploads)
          chmod +x roku-enhancement-integration.sh 2>/dev/null || true
          
          # Run the enhancement (reads local roku-feed.json)
          bash roku-enhancement-integration.sh
          
          echo "âœ… Roku enhancement completed"
        else
          echo "â„¹ï¸ Roku enhancer not found - skipping enhancement"
        fi    
    
    - name: Create index page
      run: |
        echo "ðŸ“„ Creating feed index page..."
        
        cat > index.html << 'EOF'
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Heritage Church of Christ - Media Feeds</title>
            <style>
                body { 
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
                    max-width: 900px; 
                    margin: 0 auto; 
                    padding: 20px; 
                    background: #f8f9fa;
                }
                .header { text-align: center; margin-bottom: 40px; }
                .feed-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
                .feed-card { 
                    background: white; 
                    padding: 20px; 
                    border-radius: 8px; 
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    text-decoration: none;
                    color: inherit;
                    transition: transform 0.2s;
                }
                .feed-card:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
                .feed-title { font-size: 1.2em; font-weight: bold; margin-bottom: 10px; color: #2c3e50; }
                .feed-description { color: #666; margin-bottom: 15px; }
                .feed-button { 
                    background: #3498db; 
                    color: white; 
                    padding: 8px 16px; 
                    border-radius: 4px; 
                    text-decoration: none; 
                    display: inline-block;
                    margin-right: 10px;
                    margin-bottom: 5px;
                }
                .phone-info { background: #e8f5e8; border-left: 4px solid #27ae60; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Heritage Church of Christ</h1>
                <p>Sermons and Media Feeds</p>
            </div>
            
            <div class="feed-grid">
                <a href="feed-video.xml" class="feed-card">
                    <div class="feed-title">ðŸ“º Video Podcast</div>
                    <div class="feed-description">Full video sermons for video podcast apps and Apple Podcasts</div>
                    <span class="feed-button">Subscribe to Video Feed</span>
                </a>
                
                <a href="roku-feed.json" class="feed-card">
                    <div class="feed-title">ðŸ“± Roku Channel</div>
                    <div class="feed-description">JSON feed for Roku Direct Publisher streaming channel</div>
                    <span class="feed-button">View Roku Feed</span>
                </a>
                
                <div class="feed-card phone-info">
                    <div class="feed-title">ðŸ“ž Phone Tree Audio</div>
                    <div class="feed-description">Latest sermon in phone-optimized quality with smart trimming</div>
                    <a href="latest-sermon-phone.mp3" class="feed-button">Download Trimmed</a>
                    <a href="latest-sermon-phone-full.mp3" class="feed-button">Download Full</a>
                    <a href="phone-tree-info.json" class="feed-button">Info JSON</a>
                </div>
            </div>
            
            <div style="margin-top: 40px; text-align: center; color: #666;">
                <p>Updated automatically every 2 hours â€¢ Special checks Sunday evenings</p>
                <p><a href="https://heritagecoc.org">Visit our website</a></p>
            </div>
        </body>
        </html>
        EOF
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "Comprehensive Media Generator"
        
        # Add generated files and tracking files
        git add feed-video.xml roku-feed.json latest-sermon-phone.mp3 latest-sermon-phone-full.mp3 phone-tree-info.json index.html .content-hash .latest-episode phone-audio-decisions.log 2>/dev/null || true
        
        if git diff --cached --quiet; then
          echo "â„¹ï¸ No changes to commit"
        else
          echo "ðŸ“ Changes detected - committing..."
          git status
          git commit -m "ðŸŽ™ï¸ Auto-update comprehensive media feeds - $(date '+%Y-%m-%d %H:%M UTC')"
          git push
          echo "âœ… Comprehensive media feeds updated successfully!"
        fi
