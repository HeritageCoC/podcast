name: Multi-Platform Media Generator

on:
  schedule:
    - cron: '0 */2 * * *'  # Check every 2 hours
    - cron: '0 18 * * 0'   # Special check Sundays at 6pm Central (00:00 UTC Monday)
  workflow_dispatch:
    inputs:
      force_refresh:
        description: 'Force refresh all episodes'
        required: false
        default: false
        type: boolean
      skip_sermon_check:
        description: 'Skip missing sermon detection'
        required: false
        default: false
        type: boolean
  push:
    branches: [ main ]
    paths:
      - 'config.json'

permissions:
  contents: write

jobs:
  validate-and-check:
    runs-on: ubuntu-latest
    outputs:
      should-continue: ${{ steps.sermon-check.outputs.should-continue }}
      sermon-status: ${{ steps.sermon-check.outputs.status }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Validate configuration
      run: |
        echo "ðŸ” Validating configuration..."
        
        if [ ! -f "config.json" ]; then
          echo "âŒ config.json not found!"
          exit 1
        fi
        
        if ! jq . config.json > /dev/null 2>&1; then
          echo "âŒ config.json contains invalid JSON!"
          exit 1
        fi
        
        echo "âœ… Configuration valid"
        jq '.outputs' config.json
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Check for missing sermon
      id: sermon-check
      run: |
        echo "ðŸ• Checking for expected sermon..."
        
        cat > check-sermon.js << 'SCRIPT_EOF'
        const fs = require('fs');
        const https = require('https');
        
        let config;
        try {
          config = JSON.parse(fs.readFileSync('config.json', 'utf8'));
        } catch (error) {
          console.error('âŒ Error reading config:', error);
          process.exit(1);
        }
        
        function getCentralTime() {
          const now = new Date();
          const centralTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          return centralTime;
        }
        
        function getLastSunday() {
          const now = getCentralTime();
          const dayOfWeek = now.getDay(); // 0 = Sunday
          const daysBack = dayOfWeek === 0 ? 0 : dayOfWeek;
          const lastSunday = new Date(now);
          lastSunday.setDate(now.getDate() - daysBack);
          lastSunday.setHours(11, 0, 0, 0); // 11 AM service time
          return lastSunday;
        }
        
        function shouldCheckForSermon() {
          if (process.env.SKIP_SERMON_CHECK === 'true') {
            console.log('ðŸ“‹ Sermon check skipped by user input');
            return false;
          }
          
          const now = getCentralTime();
          const lastSunday = getLastSunday();
          const dayOfWeek = now.getDay();
          const hour = now.getHours();
          
          // Check on Sunday after 5 PM, or any time Monday-Saturday
          const shouldCheck = (dayOfWeek === 0 && hour >= 17) || dayOfWeek > 0;
          
          console.log('ðŸ“… Current time: ' + now.toLocaleString());
          console.log('ðŸ“… Last Sunday service: ' + lastSunday.toLocaleString());
          console.log('ðŸ” Should check for sermon: ' + shouldCheck);
          
          return shouldCheck;
        }
        
        async function fetchVimeoData() {
          return new Promise((resolve, reject) => {
            const url = config.vimeoFeedUrl || config.platformConfigs?.vimeo?.feedUrl;
            if (!url) {
              reject(new Error('No Vimeo feed URL configured'));
              return;
            }
            
            console.log('ðŸ“¡ Fetching from:', url);
            
            https.get(url, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                try {
                  const vimeoData = JSON.parse(data);
                  resolve(vimeoData);
                } catch (error) {
                  reject(error);
                }
              });
            }).on('error', reject);
          });
        }
        
        async function sendPushoverNotification(message, priority = 0) {
          if (!config.pushover?.enabled) {
            console.log('ðŸ“± Pushover disabled, skipping notification');
            return;
          }
          
          const userKey = process.env.PUSHOVER_USER_KEY;
          const appToken = process.env.PUSHOVER_APP_TOKEN;
          
          if (!userKey || !appToken) {
            console.error('âŒ Pushover credentials not configured');
            return;
          }
          
          const postData = JSON.stringify({
            token: appToken,
            user: userKey,
            message: message,
            title: 'Sermon Feed Alert',
            priority: priority,
            sound: priority > 0 ? 'falling' : 'pushover'
          });
          
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.pushover.net',
              port: 443,
              path: '/1/messages.json',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
              }
            };
            
            const req = https.request(options, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                if (res.statusCode === 200) {
                  console.log('ðŸ“± Pushover notification sent successfully');
                  resolve(data);
                } else {
                  console.error('âŒ Pushover notification failed:', res.statusCode, data);
                  reject(new Error('Pushover failed: ' + res.statusCode));
                }
              });
            });
            
            req.on('error', reject);
            req.write(postData);
            req.end();
          });
        }
        
        async function checkSermonExpectation(vimeoData) {
          const lastSunday = getLastSunday();
          const graceHours = config.schedule?.graceHours || 6;
          const gracePeriod = new Date(lastSunday.getTime() + (graceHours * 60 * 60 * 1000));
          
          if (!vimeoData.movies || vimeoData.movies.length === 0) {
            return {
              isMissing: true,
              message: 'No videos found in Vimeo feed',
              shouldStop: true
            };
          }
          
          // Get the most recent video
          const latestVideo = vimeoData.movies
            .sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate))[0];
          
          const latestDate = new Date(latestVideo.releaseDate);
          const timeSinceService = getCentralTime() - lastSunday;
          const timeSinceLatest = getCentralTime() - latestDate;
          
          console.log('ðŸ“¹ Latest video: "' + latestVideo.title + '"');
          console.log('ðŸ“… Latest video date (raw): ' + latestVideo.releaseDate);
          console.log('ðŸ“… Latest video date (parsed): ' + latestDate.toLocaleString());
          console.log('â° Time since service: ' + Math.round(timeSinceService / (1000 * 60 * 60)) + ' hours');
          console.log('â° Time since latest video: ' + Math.round(timeSinceLatest / (1000 * 60 * 60)) + ' hours');
          
          // Account for Vimeo's 7-day date offset issue
          const adjustedLatestDate = new Date(latestDate.getTime() + (7 * 24 * 60 * 60 * 1000)); // Add 7 days
          const adjustedTimeSinceLatest = getCentralTime() - adjustedLatestDate;
          
          console.log('ðŸ“… Adjusted latest video date (+7 days): ' + adjustedLatestDate.toLocaleString());
          console.log('â° Adjusted time since latest video: ' + Math.round(adjustedTimeSinceLatest / (1000 * 60 * 60)) + ' hours');
          
          // Check if adjusted date is from expected service
          const videoFromExpectedService = adjustedLatestDate >= lastSunday && adjustedLatestDate <= gracePeriod;
          
          // Also check if the video was uploaded recently (within last 24 hours) regardless of date
          const wasUploadedRecently = Math.abs(adjustedTimeSinceLatest) < (24 * 60 * 60 * 1000);
          
          console.log('ðŸŽ¯ Video from expected service window: ' + videoFromExpectedService);
          console.log('ðŸ• Video uploaded recently: ' + wasUploadedRecently);
          
          if (!videoFromExpectedService && !wasUploadedRecently && timeSinceService > (graceHours * 60 * 60 * 1000)) {
            const message = 'Missing expected sermon from ' + lastSunday.toLocaleDateString() + '. Latest video: "' + latestVideo.title + '" from ' + latestVideo.releaseDate + ' (Vimeo date may be offset).';
            
            await sendPushoverNotification(message, 1); // High priority
            
            return {
              isMissing: true,
              message: message,
              shouldStop: true
            };
          }
          
          return {
            isMissing: false,
            message: 'Latest sermon found: "' + latestVideo.title + '" (accounting for Vimeo date offset)',
            shouldStop: false
          };
        }
        
        async function main() {
          try {
            if (!shouldCheckForSermon()) {
              console.log('âœ… Sermon check not needed at this time');
              console.log('should-continue=true');
              console.log('status=skipped');
              return;
            }
            
            const vimeoData = await fetchVimeoData();
            const result = await checkSermonExpectation(vimeoData);
            
            console.log('ðŸ“Š Sermon check result: ' + result.message);
            
            if (result.shouldStop) {
              console.log('should-continue=false');
              console.log('status=missing');
            } else {
              console.log('should-continue=true');
              console.log('status=found');
            }
            
          } catch (error) {
            console.error('âŒ Error during sermon check:', error);
            
            // Send error notification
            if (config.pushover?.enabled) {
              await sendPushoverNotification('Sermon check failed: ' + error.message, 0);
            }
            
            console.log('should-continue=true'); // Continue on error
            console.log('status=error');
          }
        }
        
        main();
        SCRIPT_EOF
        
        # Run the sermon check and capture outputs
        node check-sermon.js > check_output.txt 2>&1
        
        # Extract outputs from the script
        if grep -q "should-continue=false" check_output.txt; then
          echo "should-continue=false" >> $GITHUB_OUTPUT
        else
          echo "should-continue=true" >> $GITHUB_OUTPUT
        fi
        
        if grep -q "status=missing" check_output.txt; then
          echo "status=missing" >> $GITHUB_OUTPUT
        elif grep -q "status=found" check_output.txt; then
          echo "status=found" >> $GITHUB_OUTPUT
        elif grep -q "status=skipped" check_output.txt; then
          echo "status=skipped" >> $GITHUB_OUTPUT
        else
          echo "status=error" >> $GITHUB_OUTPUT
        fi
        
        # Show the output
        cat check_output.txt
        
      env:
        PUSHOVER_USER_KEY: ${{ secrets.PUSHOVER_USER_KEY }}
        PUSHOVER_APP_TOKEN: ${{ secrets.PUSHOVER_APP_TOKEN }}
        SKIP_SERMON_CHECK: ${{ github.event.inputs.skip_sermon_check }}

  generate-feeds:
    needs: validate-and-check
    runs-on: ubuntu-latest
    if: needs.validate-and-check.outputs.should-continue == 'true'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Setup FFmpeg
      run: |
        echo "ðŸ“¦ Installing FFmpeg via apt..."
        sudo apt-get update
        sudo apt-get install -y ffmpeg
        ffmpeg -version
      
    - name: Generate all feeds and media
      run: |
        echo "ðŸš€ Starting comprehensive feed generation..."
        
        cat > generate-comprehensive.js << 'SCRIPT_EOF'
        const fs = require('fs');
        const https = require('https');
        const { spawn } = require('child_process');
        const { URL } = require('url');
        
        console.log('ðŸš€ Starting comprehensive feed generation...');
        
        let config;
        try {
          config = JSON.parse(fs.readFileSync('config.json', 'utf8'));
          console.log('âœ… Config loaded:', config.podcastTitle);
        } catch (error) {
          console.error('âŒ Error reading config:', error);
          process.exit(1);
        }
        
        // Enhanced XML escaping
        function escapeXML(str) {
          if (!str) return '';
          return str.toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/&rsquo;/g, "'")
            .replace(/&lsquo;/g, "'")
            .replace(/&ldquo;/g, '"')
            .replace(/&rdquo;/g, '"')
            .replace(/&ndash;/g, '-')
            .replace(/&mdash;/g, '--')
            .replace(/&hellip;/g, '...')
            .replace(/&nbsp;/g, ' ')
            .replace(/<[^>]*>/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        }
        
        function formatRFC2822Date(dateString) {
          const date = new Date(dateString);
          return isNaN(date.getTime()) ? new Date().toUTCString() : date.toUTCString();
        }
        
        function formatDuration(seconds) {
          if (!seconds || seconds <= 0) return '0:00';
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          return hours > 0 ? 
            hours + ':' + minutes.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0') :
            minutes + ':' + secs.toString().padStart(2, '0');
        }
        
        // Enhanced Vimeo Roku feed fetcher
        async function fetchVimeoData() {
          return new Promise((resolve, reject) => {
            const url = config.vimeoFeedUrl;
            if (!url) {
              reject(new Error('No Vimeo feed URL configured'));
              return;
            }
            
            console.log('ðŸ“¡ Fetching from Vimeo Roku feed:', url);
            
            https.get(url, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                try {
                  const vimeoData = JSON.parse(data);
                  
                  // The Vimeo Roku feed already has the right structure!
                  // Just enhance it with our additional processing
                  const episodes = vimeoData.movies?.map(movie => {
                    const videoFormats = {};
                    
                    // Extract all video formats from Roku feed
                    if (movie.content?.videos) {
                      movie.content.videos.forEach(video => {
                        if (video.videoType === 'HLS' || video.url.includes('.m3u8')) {
                          videoFormats.hls = video.url;
                        } else if (video.videoType === 'MP4') {
                          const quality = video.quality?.toLowerCase() || 'hd';
                          videoFormats['mp4_' + quality] = video.url;
                        }
                      });
                    }
                    
                    return {
                      id: movie.id,
                      title: movie.title,
                      description: movie.shortDescription || movie.title,
                      thumbnail: movie.thumbnail,
                      releaseDate: movie.releaseDate,
                      duration: movie.content?.duration || 0,
                      videoFormats: videoFormats,
                      primaryVideoUrl: movie.content?.videos?.[0]?.url,
                      quality: movie.content?.videos?.[0]?.quality || 'HD',
                      tags: movie.tags || [],
                      genres: movie.genres || [],
                      // Keep original Roku data for passthrough
                      originalRokuData: movie
                    };
                  }) || [];
                  
                  console.log('âœ… Processed ' + episodes.length + ' episodes from Vimeo Roku feed');
                  resolve({
                    ...vimeoData,
                    episodes: episodes
                  });
                } catch (error) {
                  reject(error);
                }
              });
            }).on('error', reject);
          });
        }
        
        // File size detection
        async function getFileSize(url) {
          return new Promise((resolve) => {
            try {
              const urlObj = new URL(url);
              const requester = urlObj.protocol === 'https:' ? https : require('http');
              
              const request = requester.request(url, { method: 'HEAD' }, (res) => {
                resolve(res.headers['content-length'] || '0');
              });
              
              request.on('error', () => resolve('0'));
              request.setTimeout(8000, () => {
                request.destroy();
                resolve('0');
              });
              
              request.end();
            } catch (error) {
              resolve('0');
            }
          });
        }
        
        // Video Podcast RSS Generator
        async function generateVideoRSS(vimeoData) {
          if (!config.outputs?.videoPodcast?.enabled) return null;
          
          console.log('ðŸ“º Generating video podcast RSS...');
          
          const baseUrl = config.baseUrl || 'https://heritagecoc.github.io/heritage-media-feeds';
          const artworkUrl = config.podcastArtwork?.startsWith('http') ? 
            config.podcastArtwork : baseUrl + '/' + config.podcastArtwork.replace('./', '');
          
          const now = formatRFC2822Date(new Date().toISOString());
          
          let rss = '<?xml version="1.0" encoding="UTF-8"?>\n';
          rss += '<rss version="2.0" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd">\n';
          rss += '<channel>\n';
          rss += '    <title>' + escapeXML(config.podcastTitle) + ' - Video</title>\n';
          rss += '    <link>' + escapeXML(config.churchWebsite || baseUrl) + '</link>\n';
          rss += '    <description>' + escapeXML(config.podcastDescription) + ' - Full video sermons</description>\n';
          rss += '    <language>' + escapeXML(config.podcastLanguage || 'en') + '</language>\n';
          rss += '    <pubDate>' + now + '</pubDate>\n';
          rss += '    <lastBuildDate>' + now + '</lastBuildDate>\n';
          rss += '    <itunes:author>' + escapeXML(config.podcastAuthor) + '</itunes:author>\n';
          rss += '    <itunes:image href="' + escapeXML(artworkUrl) + '" />\n';
          rss += '    <itunes:explicit>false</itunes:explicit>\n';
          
          // Use existing category structure
          if (config.podcastSubcategory) {
            rss += '    <itunes:category text="' + escapeXML(config.podcastCategory) + '">\n';
            rss += '        <itunes:category text="' + escapeXML(config.podcastSubcategory) + '" />\n';
            rss += '    </itunes:category>\n';
          } else {
            rss += '    <itunes:category text="' + escapeXML(config.podcastCategory || 'Religion & Spirituality') + '" />\n';
          }
          
          const sortedEpisodes = vimeoData.episodes.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
          
          for (let i = 0; i < sortedEpisodes.length; i++) {
            const episode = sortedEpisodes[i];
            if (!episode.primaryVideoUrl) continue;
            
            const episodeNumber = sortedEpisodes.length - i;
            const pubDate = formatRFC2822Date(episode.releaseDate);
            const duration = formatDuration(episode.duration);
            const fileSize = await getFileSize(episode.primaryVideoUrl);
            
            rss += '\n    <item>\n';
            rss += '        <title>' + escapeXML(episode.title) + '</title>\n';
            rss += '        <description>' + escapeXML(episode.description) + '</description>\n';
            rss += '        <guid isPermaLink="false">vimeo-video-' + escapeXML(episode.id) + '</guid>\n';
            rss += '        <pubDate>' + pubDate + '</pubDate>\n';
            rss += '        <enclosure url="' + escapeXML(episode.primaryVideoUrl) + '" length="' + fileSize + '" type="application/x-mpegURL" />\n';
            rss += '        <itunes:title>' + escapeXML(episode.title) + '</itunes:title>\n';
            rss += '        <itunes:duration>' + duration + '</itunes:duration>\n';
            rss += '        <itunes:episode>' + episodeNumber + '</itunes:episode>\n';
            
            if (episode.thumbnail) {
              rss += '        <itunes:image href="' + escapeXML(episode.thumbnail) + '" />\n';
            }
            
            rss += '    </item>';
          }
          
          rss += '\n\n</channel>\n</rss>';
          return rss;
        }
        
        // Enhanced Roku feed generator (optimized for existing Roku feed)
        async function generateRokuFeed(vimeoData) {
          if (!config.outputs?.roku?.enabled) return null;
          
          console.log('ðŸ“º Generating enhanced Roku Direct Publisher feed...');
          
          // Since your Vimeo feed is already Roku-compatible, we can enhance it
          const enhancedRokuFeed = {
            providerName: config.podcastAuthor,
            language: config.podcastLanguage || 'en',
            lastUpdated: new Date().toISOString(),
            movies: []
          };
          
          const sortedEpisodes = vimeoData.episodes.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
          
          for (const episode of sortedEpisodes) {
            if (!episode.primaryVideoUrl) continue;
            
            // Use original Roku data as base, then enhance
            const rokuEpisode = {
              ...episode.originalRokuData,
              // Ensure these fields are properly set
              id: episode.id,
              title: episode.title,
              shortDescription: episode.description,
              thumbnail: episode.thumbnail || '',
              releaseDate: episode.releaseDate,
              genres: episode.genres.length > 0 ? episode.genres : ['faith'],
              tags: episode.tags.length > 0 ? episode.tags : ['sermon']
            };
            
            // Ensure content structure is complete
            if (!rokuEpisode.content) {
              rokuEpisode.content = {
                dateAdded: episode.releaseDate,
                captions: [],
                duration: episode.duration,
                videos: []
              };
            }
            
            // Ensure videos array is populated
            if (!rokuEpisode.content.videos || rokuEpisode.content.videos.length === 0) {
              rokuEpisode.content.videos = [];
              
              if (episode.videoFormats.hls) {
                rokuEpisode.content.videos.push({
                  url: episode.videoFormats.hls,
                  quality: 'HD',
                  videoType: 'HLS'
                });
              }
              
              // Add MP4 versions if available
              Object.entries(episode.videoFormats).forEach(([format, url]) => {
                if (format.startsWith('mp4_')) {
                  const quality = format.replace('mp4_', '').toUpperCase();
                  rokuEpisode.content.videos.push({
                    url: url,
                    quality: quality,
                    videoType: 'MP4'
                  });
                }
              });
            }
            
            enhancedRokuFeed.movies.push(rokuEpisode);
          }
          
          return JSON.stringify(enhancedRokuFeed, null, 2);
        }
        
        // Enhanced Phone Quality MP3 Generator with Smart Trimming
        async function generatePhoneQualityMp3(vimeoData) {
          if (!config.outputs?.phoneTree?.enabled) return null;
          
          console.log('ðŸ“ž Generating phone quality MP3 with smart trimming...');
          
          const latestEpisode = vimeoData.episodes
            .sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate))[0];
          
          if (!latestEpisode || !latestEpisode.primaryVideoUrl) {
            console.warn('âš ï¸ No latest episode found for phone MP3');
            return null;
          }
          
          const smartTrimming = config.outputs.phoneTree.smartTrimming;
          const generateBoth = smartTrimming?.enabled && smartTrimming?.generateBothVersions;
          
          return new Promise((resolve, reject) => {
            console.log('ðŸŽµ Converting "' + latestEpisode.title + '" to phone quality MP3...');
            
            // Generate trimmed version first if smart trimming is enabled
            const generateTrimmed = () => {
              return new Promise((resolveTrimmed, rejectTrimmed) => {
                if (!smartTrimming?.enabled) {
                  console.log('ðŸ“± Smart trimming disabled - generating full audio');
                  generateStandardMp3(resolveTrimmed, rejectTrimmed);
                  return;
                }
                
                console.log('âœ‚ï¸ Analyzing audio for smart trimming...');
                
                // Step 1: Analyze audio to find trim points
                const analyzeArgs = [
                  '-i', latestEpisode.primaryVideoUrl,
                  '-af', 'silencedetect=noise=' + smartTrimming.silenceThreshold + 'dB:duration=5',
                  '-f', 'null',
                  '-'
                ];
                
                const analyze = spawn('ffmpeg', analyzeArgs);
                let analysisOutput = '';
                
                analyze.stderr.on('data', (data) => {
                  analysisOutput += data.toString();
                });
                
                analyze.on('close', (code) => {
                  try {
                    const trimPoints = detectTrimPoints(analysisOutput, latestEpisode.duration);
                    console.log('ðŸŽ¯ Detected trim points: ' + trimPoints.start + 's to ' + trimPoints.end + 's');
                    
                    // Step 2: Generate trimmed MP3
                    const trimmedArgs = [
                      '-i', latestEpisode.primaryVideoUrl,
                      '-ss', trimPoints.start.toString(),
                      '-to', trimPoints.end.toString(),
                      '-vn', // No video
                      '-acodec', 'mp3',
                      '-ar', '22050',
                      '-ab', '64k',
                      '-ac', '1',
                      '-f', 'mp3',
                      '-y',
                      'latest-sermon-phone.mp3'
                    ];
                    
                    const ffmpegTrimmed = spawn('ffmpeg', trimmedArgs);
                    let stderrTrimmed = '';
                    
                    ffmpegTrimmed.stderr.on('data', (data) => {
                      stderrTrimmed += data.toString();
                    });
                    
                    ffmpegTrimmed.on('close', (trimCode) => {
                      if (trimCode === 0) {
                        const trimmedInfo = {
                          title: latestEpisode.title,
                          date: latestEpisode.releaseDate,
                          originalDuration: latestEpisode.duration,
                          trimmedDuration: trimPoints.end - trimPoints.start,
                          trimStartTime: formatTime(trimPoints.start),
                          trimEndTime: formatTime(trimPoints.end),
                          trimmingApplied: true,
                          trimmedUrl: (config.baseUrl || 'https://heritagecoc.github.io/podcast') + '/latest-sermon-phone.mp3',
                          generated: new Date().toISOString()
                        };
                        
                        console.log('âœ… Trimmed MP3 generated: ' + trimmedInfo.trimmedDuration + 's (removed ' + (latestEpisode.duration - trimmedInfo.trimmedDuration) + 's)');
                        resolveTrimmed(trimmedInfo);
                      } else {
                        console.warn('
