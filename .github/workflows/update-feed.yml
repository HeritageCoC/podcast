name: Update Apple Podcasts Feed

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'config.json'

permissions:
  contents: write

jobs:
  update-feed:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Validate config.json
      run: |
        echo "üîç Validating config.json..."
        
        if [ ! -f "config.json" ]; then
          echo "‚ùå config.json not found!"
          exit 1
        fi
        
        # Validate JSON syntax
        if ! cat config.json | jq . > /dev/null 2>&1; then
          echo "‚ùå config.json contains invalid JSON!"
          exit 1
        fi
        
        echo "‚úÖ config.json is valid"
        echo "üìÑ Config contents:"
        cat config.json | jq .
        
    - name: Generate Apple Podcasts Compliant RSS Feed
      run: |
        echo "üçé Starting Apple Podcasts compliant RSS generation..."
        
        # Create package.json
        cat > package.json << 'EOF'
        {
          "type": "commonjs",
          "name": "podcast-rss-generator",
          "version": "3.0.0"
        }
        EOF
        
        # Copy the Apple compliant RSS generation script
        cat > generate-rss.js << 'SCRIPT_EOF'
        const fs = require('fs');
        const https = require('https');

        console.log('üöÄ Starting Apple Podcasts compliant RSS generation...');

        let config;
        try {
          config = JSON.parse(fs.readFileSync('config.json', 'utf8'));
          console.log('‚úÖ Config loaded:', config.podcastTitle);
        } catch (error) {
          console.error('‚ùå Error reading config:', error);
          process.exit(1);
        }

        // Apple-compliant XML escaping
        function escapeXML(str) {
            if (!str) return '';
            return str.toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;')
                // Remove HTML entities that Apple doesn't like
                .replace(/&rsquo;/g, '&apos;')
                .replace(/&lsquo;/g, '&apos;')
                .replace(/&ldquo;/g, '&quot;')
                .replace(/&rdquo;/g, '&quot;')
                .replace(/&ndash;/g, '-')
                .replace(/&mdash;/g, '-')
                .replace(/&hellip;/g, '...')
                // Remove any remaining HTML tags
                .replace(/<[^>]*>/g, '');
        }

        // RFC 2822 compliant date formatting
        function formatRFC2822Date(dateString) {
            const date = new Date(dateString);
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const dayName = days[date.getUTCDay()];
            const day = date.getUTCDate().toString().padStart(2, '0');
            const month = months[date.getUTCMonth()];
            const year = date.getUTCFullYear();
            const hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            const seconds = date.getUTCSeconds().toString().padStart(2, '0');
            
            return `${dayName}, ${day} ${month} ${year} ${hours}:${minutes}:${seconds} +0000`;
        }

        // iTunes duration format (HH:MM:SS or MM:SS)
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Get file size using HEAD request
        async function getFileSize(url) {
            return new Promise((resolve) => {
                const request = https.request(url, { method: 'HEAD' }, (res) => {
                    const contentLength = res.headers['content-length'];
                    resolve(contentLength || '0');
                });
                
                request.on('error', () => {
                    resolve('0');
                });
                
                request.setTimeout(5000, () => {
                    request.destroy();
                    resolve('0');
                });
                
                request.end();
            });
        }

        function getSampleData() {
            return {
                "providerName": config.podcastAuthor,
                "lastUpdated": new Date().toISOString(),
                "language": config.podcastLanguage,
                "movies": [
                    {"id":"1099141295","title":"The Breath of Life - Chad Hedgpath 7.13.25","shortDescription":"The Breath of Life - Chad Hedgpath 7.13.25","thumbnail":"https://i.vimeocdn.com/video/2033995829-9d172f0bf99cec1433932745b8a8ccfb30cf7f45f953c439763888cbabfb82e1-d_800x450?region=us","releaseDate":"2025-07-06T10:58:00-04:00","genres":["faith"],"tags":["faith"],"content":{"dateAdded":"2025-07-13T15:56:09-04:00","duration":4673,"videos":[{"url":"https://player.vimeo.com/external/1099141295.m3u8?s=5ce6ae724ce3f567961026b5a12094bf32d557a1","quality":"HD","videoType":"HLS","bitrate":null}]}}
                ]
            };
        }

        async function fetchVimeoData() {
            try {
                return new Promise((resolve, reject) => {
                    const url = config.vimeoFeedUrl;
                    console.log('üì° Fetching from Vimeo:', url);
                    
                    https.get(url, (res) => {
                        let data = '';
                        res.on('data', chunk => data += chunk);
                        res.on('end', () => {
                            try {
                                const vimeoData = JSON.parse(data);
                                console.log('‚úÖ Fetched ' + vimeoData.movies.length + ' episodes from Vimeo');
                                resolve(vimeoData);
                            } catch (error) {
                                console.error('‚ùå Error parsing Vimeo data:', error);
                                console.log('üîÑ Falling back to sample data');
                                resolve(getSampleData());
                            }
                        });
                    }).on('error', (error) => {
                        console.error('‚ùå Error fetching from Vimeo:', error);
                        console.log('üîÑ Falling back to sample data');
                        resolve(getSampleData());
                    });
                });
            } catch (error) {
                console.error('‚ùå Fetch error:', error);
                return getSampleData();
            }
        }

        async function generateRSS(vimeoData) {
            console.log('üìù Generating Apple Podcasts compliant RSS with ' + vimeoData.movies.length + ' episodes');
            
            const baseUrl = 'https://heritagecoc.github.io/podcast';
            const artworkUrl = config.podcastArtwork && config.podcastArtwork.startsWith('http') ? 
                config.podcastArtwork : `${baseUrl}/${(config.podcastArtwork || 'artwork.jpg').replace('./', '')}`;
            
            const now = formatRFC2822Date(new Date().toISOString());
            const buildDate = formatRFC2822Date(vimeoData.lastUpdated);
            
            // Validate required fields
            if (!config.podcastTitle || !config.podcastDescription || !config.podcastAuthor) {
                throw new Error('Missing required podcast metadata in config.json');
            }
            
            let rss = '<?xml version="1.0" encoding="UTF-8"?>\n';
            rss += '<rss version="2.0" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:content="http://purl.org/rss/1.0/modules/content/">\n';
            rss += '<channel>\n';
            
            // Required channel elements
            rss += `    <title>${escapeXML(config.podcastTitle)}</title>\n`;
            rss += `    <link>${escapeXML(config.churchWebsite || 'https://heritagecoc.org')}</link>\n`;
            rss += `    <description>${escapeXML(config.podcastDescription)}</description>\n`;
            rss += `    <language>${escapeXML(config.podcastLanguage || 'en-us')}</language>\n`;
            rss += `    <copyright>¬© ${new Date().getFullYear()} ${escapeXML(config.podcastAuthor)}</copyright>\n`;
            rss += `    <managingEditor>${escapeXML(config.podcastEmail || 'noreply@heritagecoc.org')} (${escapeXML(config.podcastAuthor)})</managingEditor>\n`;
            rss += `    <webMaster>${escapeXML(config.podcastEmail || 'noreply@heritagecoc.org')} (${escapeXML(config.podcastAuthor)})</webMaster>\n`;
            rss += `    <pubDate>${now}</pubDate>\n`;
            rss += `    <lastBuildDate>${buildDate}</lastBuildDate>\n`;
            rss += `    <generator>GitHub Actions Apple Podcasts RSS Generator v3.0</generator>\n`;
            rss += `    <docs>https://cyber.harvard.edu/rss/rss.html</docs>\n`;
            rss += `    <ttl>60</ttl>\n`;
            rss += '\n';
            
            // iTunes specific tags
            rss += '    <!-- iTunes Podcast Tags -->\n';
            rss += `    <itunes:author>${escapeXML(config.podcastAuthor)}</itunes:author>\n`;
            rss += `    <itunes:summary>${escapeXML(config.podcastDescription)}</itunes:summary>\n`;
            rss += '    <itunes:owner>\n';
            rss += `        <itunes:name>${escapeXML(config.podcastAuthor)}</itunes:name>\n`;
            rss += `        <itunes:email>${escapeXML(config.podcastEmail || 'noreply@heritagecoc.org')}</itunes:email>\n`;
            rss += '    </itunes:owner>\n';
            rss += '    <itunes:explicit>false</itunes:explicit>\n';
            
            // Category handling
            const category = config.podcastCategory || 'Religion & Spirituality';
            if (config.podcastSubcategory) {
                rss += `    <itunes:category text="${escapeXML(category)}">\n`;
                rss += `        <itunes:category text="${escapeXML(config.podcastSubcategory)}" />\n`;
                rss += '    </itunes:category>\n';
            } else {
                rss += `    <itunes:category text="${escapeXML(category)}" />\n`;
            }
            
            rss += `    <itunes:image href="${escapeXML(artworkUrl)}" />\n`;
            rss += '    <itunes:type>episodic</itunes:type>\n';
            rss += `    <itunes:new-feed-url>${baseUrl}/feed.xml</itunes:new-feed-url>\n`;

            // Process episodes
            for (let i = 0; i < vimeoData.movies.length; i++) {
                const movie = vimeoData.movies[i];
                const episodeNumber = vimeoData.movies.length - i;
                
                // Validate required episode fields
                if (!movie.id || !movie.title || !movie.content || !movie.content.videos || !movie.content.videos[0]) {
                    console.warn(`‚ö†Ô∏è Skipping episode ${movie.id} - missing required fields`);
                    continue;
                }
                
                const pubDate = formatRFC2822Date(movie.releaseDate);
                const duration = formatDuration(movie.content.duration || 0);
                const videoUrl = movie.content.videos[0].url;
                
                // Get file size for enclosure (with timeout to avoid hanging)
                console.log(`üîç Getting file size for episode ${episodeNumber}...`);
                const fileSize = await getFileSize(videoUrl);
                
                rss += '\n    <item>\n';
                rss += `        <title>${escapeXML(movie.title)}</title>\n`;
                rss += `        <description>${escapeXML(movie.shortDescription || movie.title)}</description>\n`;
                rss += `        <link>https://vimeo.com/${escapeXML(movie.id)}</link>\n`;
                
                // Apple requires unique GUIDs
                rss += `        <guid isPermaLink="false">vimeo-${escapeXML(movie.id)}</guid>\n`;
                rss += `        <pubDate>${pubDate}</pubDate>\n`;
                
                // Apple requires enclosure with proper attributes
                rss += `        <enclosure url="${escapeXML(videoUrl)}" length="${fileSize}" type="application/x-mpegURL" />\n`;
                
                // iTunes episode tags
                rss += `        <itunes:title>${escapeXML(movie.title)}</itunes:title>\n`;
                rss += `        <itunes:summary>${escapeXML(movie.shortDescription || movie.title)}</itunes:summary>\n`;
                rss += `        <itunes:duration>${duration}</itunes:duration>\n`;
                rss += `        <itunes:episode>${episodeNumber}</itunes:episode>\n`;
                rss += '        <itunes:episodeType>full</itunes:episodeType>\n';
                rss += '        <itunes:explicit>false</itunes:explicit>\n';
                
                if (movie.thumbnail) {
                    rss += `        <itunes:image href="${escapeXML(movie.thumbnail)}" />\n`;
                }
                
                rss += '    </item>';
            }

            rss += '\n\n</channel>\n</rss>';
            return rss;
        }

        async function validateXML(xmlContent) {
            // Basic XML validation checks
            const issues = [];
            
            // Check for unescaped ampersands
            const unescapedAmpersands = xmlContent.match(/&(?![a-zA-Z0-9#]{1,7};)/g);
            if (unescapedAmpersands) {
                issues.push(`Found ${unescapedAmpersands.length} unescaped ampersands`);
            }
            
            // Check for proper XML structure
            if (!xmlContent.includes('<?xml version="1.0" encoding="UTF-8"?>')) {
                issues.push('Missing XML declaration');
            }
            
            // Check for required RSS elements
            const requiredElements = ['<title>', '<description>', '<link>', '<itunes:author>', '<itunes:image'];
            requiredElements.forEach(element => {
                if (!xmlContent.includes(element)) {
                    issues.push(`Missing required element: ${element}`);
                }
            });
            
            if (issues.length > 0) {
                console.warn('‚ö†Ô∏è XML validation issues found:');
                issues.forEach(issue => console.warn(`   - ${issue}`));
                return false;
            } else {
                console.log('‚úÖ XML validation passed');
                return true;
            }
        }

        async function main() {
            try {
                console.log('üì° Getting episode data...');
                const vimeoData = await fetchVimeoData();
                
                console.log('üìù Generating Apple Podcasts compliant RSS...');
                const rss = await generateRSS(vimeoData);
                
                console.log('üîç Validating XML...');
                const isValid = await validateXML(rss);
                
                if (!isValid) {
                    console.error('‚ùå XML validation failed - check issues above');
                    process.exit(1);
                }
                
                console.log('üíæ Writing RSS to feed.xml...');
                fs.writeFileSync('feed.xml', rss, 'utf8');
                
                console.log('‚úÖ Apple Podcasts compliant RSS feed generated successfully!');
                console.log('üìÑ File size: ' + fs.statSync('feed.xml').size + ' bytes');
                console.log('üïê Generated at: ' + new Date().toISOString());
                
            } catch (error) {
                console.error('‚ùå Error generating RSS:', error);
                process.exit(1);
            }
        }

        main();
        SCRIPT_EOF
        
        echo "üìù Running Apple Podcasts compliant RSS generation script..."
        node generate-rss.js
        
        if [ -f "feed.xml" ]; then
          echo "‚úÖ feed.xml created successfully!"
          echo "üìÑ File size: $(wc -c < feed.xml) bytes"
          echo "üìù First few lines:"
          head -15 feed.xml
        else
          echo "‚ùå feed.xml was not created!"
          exit 1
        fi
        
    - name: Validate RSS Feed
      run: |
        echo "üîç Additional RSS feed validation..."
        
        # Install xmllint for validation
        sudo apt-get update && sudo apt-get install -y libxml2-utils
        
        # Validate XML syntax
        echo "üß™ Testing XML syntax..."
        if xmllint --noout feed.xml; then
          echo "‚úÖ XML syntax is valid"
        else
          echo "‚ùå XML syntax validation failed"
          exit 1
        fi
        
        # Check for Apple Podcasts required elements
        echo "üçé Checking Apple Podcasts requirements..."
        
        required_elements=(
          "<title>"
          "<description>"
          "<link>"
          "<itunes:author>"
          "<itunes:image"
          "<itunes:category"
          "<itunes:owner>"
          "<itunes:explicit>"
          "<guid"
          "<enclosure"
        )
        
        for element in "${required_elements[@]}"; do
          if grep -q "$element" feed.xml; then
            echo "‚úÖ Found required element: $element"
          else
            echo "‚ùå Missing required element: $element"
            exit 1
          fi
        done
        
        echo "üéâ All Apple Podcasts requirements validated!"
        
    - name: Test RSS Feed URL
      run: |
        echo "üåê Testing RSS feed accessibility..."
        
        # Start a simple HTTP server in background
        python3 -m http.server 8000 &
        SERVER_PID=$!
        
        # Wait for server to start
        sleep 2
        
        # Test if feed is accessible
        if curl -f http://localhost:8000/feed.xml > /dev/null 2>&1; then
          echo "‚úÖ RSS feed is accessible via HTTP"
        else
          echo "‚ùå RSS feed is not accessible"
          kill $SERVER_PID
          exit 1
        fi
        
        # Stop the server
        kill $SERVER_PID
        
    - name: Commit updated feed
      run: |
        echo "üîç Checking for changes to feed.xml..."
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action RSS Bot"
        
        if git diff --quiet feed.xml; then
          echo "‚ÑπÔ∏è No changes to feed.xml - skipping commit"
        else
          echo "üìù Changes detected in feed.xml - committing..."
          git add feed.xml
          git status
          git commit -m "üéôÔ∏è Auto-update Apple Podcasts RSS feed - $(date '+%Y-%m-%d %H:%M UTC')"
          git push
          echo "‚úÖ Apple Podcasts RSS feed updated and committed successfully!"
        fi
